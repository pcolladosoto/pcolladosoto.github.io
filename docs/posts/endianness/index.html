<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Checking a system&#39;s endianness | Just another Jedi...</title>
<meta name="keywords" content="fundamentals, programming, c, go">
<meta name="description" content="So&hellip; what&rsquo;s endianness? Put simply, the endianness of a machine tells us how that machine&rsquo;s memory is organised. In order to fully grasp what that means we need to take a small step back and take a look at how we interact with a computer&rsquo;s memory.
Before we begin note we&rsquo;ll make extensive use of hexadecimal (i.e. hex) numbers. When we&rsquo;re using them we&rsquo;ll prefix them with 0x.
What was memory again?">
<meta name="author" content="Pablo Collado Soto">
<link rel="canonical" href="https://pcolladosoto.github.io/posts/endianness/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a86159a73db327948c7febaf1826dc57ee82eaaa0ad85d7e32ef3abb8c655650.css" integrity="sha256-qGFZpz2zJ5SMf&#43;uvGCbcV&#43;6C6qoK2F1&#43;Mu86u4xlVlA=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://pcolladosoto.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://pcolladosoto.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://pcolladosoto.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://pcolladosoto.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://pcolladosoto.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Checking a system&#39;s endianness" />
<meta property="og:description" content="So&hellip; what&rsquo;s endianness? Put simply, the endianness of a machine tells us how that machine&rsquo;s memory is organised. In order to fully grasp what that means we need to take a small step back and take a look at how we interact with a computer&rsquo;s memory.
Before we begin note we&rsquo;ll make extensive use of hexadecimal (i.e. hex) numbers. When we&rsquo;re using them we&rsquo;ll prefix them with 0x.
What was memory again?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://pcolladosoto.github.io/posts/endianness/" /><meta property="og:image" content="https://pcolladosoto.github.io/me.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-26T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-04-26T00:00:00+00:00" /><meta property="og:site_name" content="Just another Jedi..." />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://pcolladosoto.github.io/me.png"/>

<meta name="twitter:title" content="Checking a system&#39;s endianness"/>
<meta name="twitter:description" content="So&hellip; what&rsquo;s endianness? Put simply, the endianness of a machine tells us how that machine&rsquo;s memory is organised. In order to fully grasp what that means we need to take a small step back and take a look at how we interact with a computer&rsquo;s memory.
Before we begin note we&rsquo;ll make extensive use of hexadecimal (i.e. hex) numbers. When we&rsquo;re using them we&rsquo;ll prefix them with 0x.
What was memory again?"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://pcolladosoto.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Checking a system's endianness",
      "item": "https://pcolladosoto.github.io/posts/endianness/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Checking a system's endianness",
  "name": "Checking a system\u0027s endianness",
  "description": "So\u0026hellip; what\u0026rsquo;s endianness? Put simply, the endianness of a machine tells us how that machine\u0026rsquo;s memory is organised. In order to fully grasp what that means we need to take a small step back and take a look at how we interact with a computer\u0026rsquo;s memory.\nBefore we begin note we\u0026rsquo;ll make extensive use of hexadecimal (i.e. hex) numbers. When we\u0026rsquo;re using them we\u0026rsquo;ll prefix them with 0x.\nWhat was memory again?",
  "keywords": [
    "fundamentals", "programming", "c", "go"
  ],
  "articleBody": "So… what’s endianness? Put simply, the endianness of a machine tells us how that machine’s memory is organised. In order to fully grasp what that means we need to take a small step back and take a look at how we interact with a computer’s memory.\nBefore we begin note we’ll make extensive use of hexadecimal (i.e. hex) numbers. When we’re using them we’ll prefix them with 0x.\nWhat was memory again? When a program runs it needs some ‘space’ on which to save its contents. We call that space the memory. Now, when we discuss memory we usually differentiate among the stack and the heap and so on and so forth. That’s of no interest to us now though! We just need to know we store stuff on memory and that we can recover whatever we store there through an address. Just like in normal life, an address tells us where something (i.e. a piece of data) is.\nEach memory address identifies a single byte. We can picture something like:\nAddress + -------------- + | | 0x0 | 1 byte of data | | | + -------------- + | | 0x1 | 1 byte of data | | | + -------------- + | | 0x2 | 1 byte of data | | | + -------------- + See, each of the boxes holds one byte of data and we can refer to each of the boxes through their addresses.\nHow many boxes do we need Whenever we work with a programming language we need to be informed of the size of its data types. That is, how many boxes a variable of a given type needs. From now on we’ll use C as an example given it’s very well suited to this type of discussion: it’s data types are very simple!\nIn C, a char takes up a single byte. Then, we just need a single address to locate a char un memory:\nAddress + -------------- + | 'A' | 0x0 | | | 0011 0001 | + -------------- + Note the above address (i.e. we provide it in hex as that’s the convention) holds character 'A' which, according to the ASCII table is 49 == 0x31, which we represent in binary.\nOkay, but, what happens with a data type taking up more than one byte? Do we need an address for each of the bytes? Well no! That would make them very unwieldy… What we do instead is locate the entire thing by knowing the address of the first byte and the number of bytes we need to rebuild anything we store on memory. That’s what we actually did before too, but we knew a char is only 1 byte long!\nIn C integers (i.e. ints) take up 4 bytes. Let’s see what 0x00133539 would look like:\nAddress Address + ---- + + ---- + 0x0 | 0x00 | 0x0 | 0x39 | + ---- + + ---- + 0x1 | 0x13 | 0x1 | 0x35 | + ---- + + ---- + 0x2 | 0x35 | 0x2 | 0x13 | + ---- + + ---- + 0x3 | 0x39 | 0x3 | 0x00 | + ---- + + ---- + So… which one is correct? Both are, kind of. We can always say that this integer starts at 0x0 and is 4 bytes long. The thing is we would get back 0x00133539 if we read out the first option sequentially and 0x39351300 if we instead went with the second one. If we told you the order we followed when storing the number you’d know which of the two options to choose. That’s exactly what endianness is!\nThe two types of endianness In a big endian machine we say ’the high order byte goes to the lower address’. That is, the byte with the largest weight (i.e. 0x00 in our example) would be stored at the low address and we would then store the rest of the data in the subsequent addresses. The ‘good’ thing with big endianness is that the memory layout resembles how we read numbers a bit more closely. In the example above the layout on the left uses big endian organisation. In the realm of networking information is expected to be mainly in big endian form (or, network order).\nIn little endian machines we say ’the low order byte goes to the lower address’. Now, the byte with the smallest weight (i.e. 0x39) is stored at the lowest address. Even though this ‘flips’ the number in memory, it does sound a bit more logical. In the previous example, the layout on the right follows a little endian organisation. ARM processors and most others use a little endian model.\nAfter reading these two examples you can see how we often need to ‘flip’ from the big to the little world. Functions such as htons(3) take care of all this and on some languages that’s ‘automagically’ done for us!\nNow that we know what endianness is let’s see how we can check the organisation of our own machine!\nTime to check our system In order to do so we’ll have to get a bit ’nasty’ with programming. As you might already be fearing, ’nasty’ is (almost) a synonym for pointers :scream:.\nA brief word on pointers Some people love pointers and others don’t: we’re not trying to settle that debate. We’re just here to tell you a pointer is a variable whose value is a memory address, nothing more.\nWe need to make use of pointers to work with the memory addresses in an unrestricted manner to decide whether we are on a little or big endian system.\nBear in mind we’ll be writing very unsafe code: we’ll be explicitly mangling data types to do what we want!\nC We’ll take a tour through time and offer a solution in two different programming languages. We’ll begin at the beginning: C. The following snippet will print a message with the system’s endianness:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // We need printf() #include int main(void) { // We define 4 byte integer x whose value is 1 int x = 0x1; // We define ptr_x as a pointer to an integer holding the address of x int* ptr_x = \u0026x; // We define ptrb_x as a pointer to a character pointing to the first address of x char* ptrb_x = (char*) ptr_x; // We get the value of the first byte of x through the dereference (i.e. *) operator char x_0 = *ptrb_x; // If the first byte is 1 then we are working on a little endian environment. // If it's a 0, then it's a big endian one! if (x_0 == 1) printf(\"Little endian!\\n\"); else printf(\"Big endian!\\n\"); return 0; } The above can be rewritten in a more succinct manner too!\n1 2 3 4 5 6 7 8 9 10 11 12 #include int main(void) { int x = 0x1; // Note that in C 'not 0 is considered true' and '0 is considered false' if (*(char*)\u0026x) printf(\"Little endian!\\n\"); else printf(\"Big endian!\\n\"); return 0; } You can compile any of the above on Linux-based machines and macOS with:\n# We assume the above code is stored on a file called endianness.c gcc -o endianness endianness.c # Once compiled we can run it with ./endianness So what the hell is going on? Let’s see the memory’s state as the statements are executed. When we define x = 0x1 we have:\nAddress Big Endian Little Endian + ---- + + ---- + 0x0 | 0x00 | | 0x01 | + ---- + + ---- + 0x1 | 0x00 | | 0x00 | + ---- + + ---- + 0x2 | 0x00 | | 0x00 | + ---- + + ---- + 0x3 | 0x01 | | 0x00 | + ---- + + ---- + Now, if we just try to get the value of x through a pointer to an integer we’ll always get 1 back. That’s because C knows that when we retrieve data pointed to by a pointer to an integer (i.e. int*) it needs to read 4 bytes! We instead need to ‘force’ it to just read the first one because that’s the one ’telling’ us about the machine’s endianness! We can do so if we ’lie’ and say that the address contained in ptr_x is instead pointing to a single byte (i.e. a char). That’s what we accomplish with a type cast like (char*) ptr_x. After casting the pointer we just need to dereference it (i.e. get its value) with * and see what we get back.\nAccording to the diagram above we can easily see how, if we retrieve the first byte and it’s a 1 we on a little endian machine and, if it’s a 0, we’re instead on a big endian system. This is exactly what the if clause checks for!\nSo, even though it looks hard and cryptic you can actually see it’s not that complex in the end is it?\nGo When working with Go we need to bend the language to our will just like with C. The thing is, Go is a bit more stubborn…\nAs we’ll be playing with types and trying to override some security features that usually prevent things from going berserk we’ll need to leverage the unsafe package.\nThe idea is pretty much the same as before: we just store 1 on a 4 byte int and then we define a pointer to said variable. In a normal scenario we would only be capable of defining a pointer to an int (i.e. a *int), but thanks to unsafe’s Pointer type we can circumvent that that restriction.\nUsing that ’trick’ we’ll instead define a pointer to a byte (i.e. a char in C’s lingo) and just take a look at the value contained in that first address. Just like before, the result of the dereference operator (i.e. *) will tell us all we need to know.\nGiven C’s ’not 0 is true’ policy is not as standard in Go we decided to explicitly check whether the returned value is 1 or not. We also chose to explicitly define px *byte instead of writing it all within the if clause to make things a bit clearer: we feel Go is not as geared towards cryptic expressions as C.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \"fmt\" \"unsafe\" ) func main() { var x int = 1 var px *byte = (*byte)(unsafe.Pointer(\u0026x)) if *px == 1 { fmt.Printf(\"Little endian!\\n\") } else { fmt.Printf(\"Big endian!\\n\") } } If you store that on a file named endianness.go and run the following you’ll get your result too:\ngo run endianness.go The idea and memory layout is exactly the same as before!\nThat’s it! Well, we did really dig into C’s and Go’s ‘belly’ there! Time for a pat in the back :clap:\nIf you have any comments, questions or suggestions, feel free to drop me an email!\nThanks for your time! Hope you found this useful :smile_cat:\n",
  "wordCount" : "1873",
  "inLanguage": "en",
  "datePublished": "2022-04-26T00:00:00Z",
  "dateModified": "2022-04-26T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Pablo Collado Soto"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://pcolladosoto.github.io/posts/endianness/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Just another Jedi...",
    "logo": {
      "@type": "ImageObject",
      "url": "https://pcolladosoto.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://pcolladosoto.github.io/" accesskey="h" title="Just another Jedi... (Alt + H)">Just another Jedi...</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://pcolladosoto.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://pcolladosoto.github.io/flatland/" title="FlatLand">
                    <span>FlatLand</span>
                </a>
            </li>
            <li>
                <a href="https://pcolladosoto.github.io/synth/" title="Synth">
                    <span>Synth</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Checking a system&#39;s endianness
    </h1>
    <div class="post-meta"><span title='2022-04-26 00:00:00 +0000 UTC'>26046-04-26</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1873 words&nbsp;·&nbsp;Pablo Collado Soto

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#what-was-memory-again">What was memory again?</a>
      <ul>
        <li><a href="#how-many-boxes-do-we-need">How many boxes do we need</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#a-brief-word-on-pointers">A brief word on pointers</a></li>
    <li><a href="#c">C</a></li>
    <li><a href="#go">Go</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="so-whats-endianness">So&hellip; what&rsquo;s endianness?<a hidden class="anchor" aria-hidden="true" href="#so-whats-endianness">#</a></h1>
<p>Put simply, the <a href="https://en.wikipedia.org/wiki/Endianness"><em>endianness</em></a> of a machine tells us how that machine&rsquo;s memory is organised. In order to fully grasp what that means we need to take a small step back and take a look at how we interact with a computer&rsquo;s memory.</p>
<p>Before we begin note we&rsquo;ll make extensive use of hexadecimal (i.e. hex) numbers. When we&rsquo;re using them we&rsquo;ll prefix them with <code>0x</code>.</p>
<h2 id="what-was-memory-again">What was memory again?<a hidden class="anchor" aria-hidden="true" href="#what-was-memory-again">#</a></h2>
<p>When a program runs it needs some &lsquo;space&rsquo; on which to save its contents. We call that space the <em>memory</em>. Now, when we discuss memory we usually differentiate among the <em>stack</em> and the <em>heap</em> and so on and so forth. That&rsquo;s of no interest to us now though! We just need to know we <em>store</em> stuff on memory and that we can recover whatever we store there through an <em>address</em>. Just like in normal life, an address tells us where something (i.e. a piece of data) is.</p>
<p>Each memory address identifies a single <em>byte</em>. We can picture something like:</p>
<pre><code>Address
          + -------------- +
          |                |
   0x0    | 1 byte of data |
          |                |
          + -------------- +
          |                |
   0x1    | 1 byte of data |
          |                |
          + -------------- +
          |                |
   0x2    | 1 byte of data |
          |                |
          + -------------- +
</code></pre>
<p>See, each of the boxes holds one byte of data and we can refer to each of the boxes through their addresses.</p>
<h3 id="how-many-boxes-do-we-need">How many boxes do we need<a hidden class="anchor" aria-hidden="true" href="#how-many-boxes-do-we-need">#</a></h3>
<p>Whenever we work with a programming language we need to be informed of the <em>size</em> of its data types. That is, how many boxes a variable of a given type needs. From now on we&rsquo;ll use <em>C</em> as an example given it&rsquo;s very well suited to this type of discussion: it&rsquo;s data types are very simple!</p>
<p>In C, a <code>char</code> takes up a <strong>single byte</strong>. Then, we just need a single address to locate a char un memory:</p>
<pre><code>Address
          + -------------- +
          |       'A'      |
   0x0    |                |
          |    0011 0001   |
          + -------------- +
</code></pre>
<p>Note the above address (i.e. we provide it in hex as that&rsquo;s the convention) holds character <code>'A'</code> which, according to the <a href="https://www.asciitable.com">ASCII table</a> is <code>49 == 0x31</code>, which we represent in binary.</p>
<p>Okay, but, what happens with a data type taking up more than one byte? Do we need an address for each of the bytes? Well no! That would make them very unwieldy&hellip; What we do instead is locate the entire thing by knowing the address of the first byte <strong>and</strong> the number of bytes we need to rebuild anything we store on memory. That&rsquo;s what we actually did before too, but we knew a <code>char</code> is only 1 byte long!</p>
<p>In C integers (i.e. <code>int</code>s) take up <strong>4 bytes</strong>. Let&rsquo;s see what <code>0x00133539</code> would look like:</p>
<pre><code>Address                Address
          + ---- +              + ---- +
   0x0    | 0x00 |       0x0    | 0x39 |
          + ---- +              + ---- +
   0x1    | 0x13 |       0x1    | 0x35 |
          + ---- +              + ---- +
   0x2    | 0x35 |       0x2    | 0x13 |
          + ---- +              + ---- +
   0x3    | 0x39 |       0x3    | 0x00 |
          + ---- +              + ---- +
</code></pre>
<p>So&hellip; which one is correct? Both are, kind of. We can always say that this integer starts at <code>0x0</code> and is <strong>4 bytes long</strong>. The thing is we would get back <code>0x00133539</code> if we read out the first option sequentially and <code>0x39351300</code> if we instead went with the second one. If we told you the order we followed when storing the number you&rsquo;d know which of the two options to choose. That&rsquo;s exactly what <strong>endianness</strong> is!</p>
<h1 id="the-two-types-of-endianness">The two types of endianness<a hidden class="anchor" aria-hidden="true" href="#the-two-types-of-endianness">#</a></h1>
<p>In a <strong>big endian</strong> machine we say <em>&rsquo;the high order byte goes to the lower address&rsquo;</em>. That is, the byte with the largest weight (i.e. <code>0x00</code> in our example) would be stored at the low address and we would then store the rest of the data in the subsequent addresses. The &lsquo;good&rsquo; thing with big endianness is that the memory layout resembles how we read numbers a bit more closely. In the example above the layout on the left uses big endian organisation. In the realm of networking information is expected to be mainly in big endian form (or, <em>network order</em>).</p>
<p>In <strong>little endian</strong> machines we say <em>&rsquo;the low order byte goes to the lower address&rsquo;</em>. Now, the byte with the smallest weight (i.e. <code>0x39</code>) is stored at the lowest address. Even though this &lsquo;flips&rsquo; the number in memory, it does sound a bit more logical. In the previous example, the layout on the right follows a little endian organisation. ARM processors and most others use a little endian model.</p>
<p>After reading these two examples you can see how we often need to &lsquo;flip&rsquo; from the big to the little world. Functions such as <a href="https://linux.die.net/man/3/htons"><code>htons(3)</code></a> take care of all this and on some languages that&rsquo;s &lsquo;automagically&rsquo; done for us!</p>
<p>Now that we know what endianness is let&rsquo;s see how we can check the organisation of our own machine!</p>
<h1 id="time-to-check-our-system">Time to check our system<a hidden class="anchor" aria-hidden="true" href="#time-to-check-our-system">#</a></h1>
<p>In order to do so we&rsquo;ll have to get a bit &rsquo;nasty&rsquo; with programming. As you might already be fearing, &rsquo;nasty&rsquo; is (almost) a synonym for <em>pointers</em> :scream:.</p>
<h2 id="a-brief-word-on-pointers">A brief word on pointers<a hidden class="anchor" aria-hidden="true" href="#a-brief-word-on-pointers">#</a></h2>
<p>Some people love <em>pointers</em> and others don&rsquo;t: we&rsquo;re not trying to settle that debate. We&rsquo;re just here to tell you a pointer is a variable whose value is a memory address, nothing more.</p>
<p>We need to make use of pointers to work with the memory addresses in an unrestricted manner to decide whether we are on a little or big endian system.</p>
<p>Bear in mind we&rsquo;ll be writing <strong>very unsafe code</strong>: we&rsquo;ll be explicitly mangling data types to do what we want!</p>
<h2 id="c">C<a hidden class="anchor" aria-hidden="true" href="#c">#</a></h2>
<p>We&rsquo;ll take a tour through time and offer a solution in two different programming languages. We&rsquo;ll begin at the beginning: <em>C</em>. The following snippet will print a message with the system&rsquo;s endianness:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// We need printf()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// We define 4 byte integer x whose value is 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// We define ptr_x as a pointer to an integer holding the address of x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span><span class="o">*</span> <span class="n">ptr_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// We define ptrb_x as a pointer to a character pointing to the first address of x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span><span class="o">*</span> <span class="n">ptrb_x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">ptr_x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// We get the value of the first byte of x through the dereference (i.e. *) operator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">x_0</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptrb_x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// If the first byte is 1 then we are working on a little endian environment.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// If it&#39;s a 0, then it&#39;s a big endian one!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">x_0</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Little endian!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Big endian!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The above can be rewritten in a more succinct manner too!</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Note that in C &#39;not 0 is considered true&#39; and &#39;0 is considered false&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Little endian!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Big endian!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>You can compile any of the above on Linux-based machines and macOS with:</p>
<pre><code># We assume the above code is stored on a file called endianness.c
gcc -o endianness endianness.c

# Once compiled we can run it with
./endianness
</code></pre>
<p>So what the hell is going on? Let&rsquo;s see the memory&rsquo;s state as the statements are executed. When we define <code>x = 0x1</code> we have:</p>
<pre><code>Address    Big Endian     Little Endian
            + ---- +        + ---- +
   0x0      | 0x00 |        | 0x01 |
            + ---- +        + ---- +
   0x1      | 0x00 |        | 0x00 |
            + ---- +        + ---- +
   0x2      | 0x00 |        | 0x00 |
            + ---- +        + ---- +
   0x3      | 0x01 |        | 0x00 |
            + ---- +        + ---- +
</code></pre>
<p>Now, if we just try to get the value of <code>x</code> through a pointer to an integer we&rsquo;ll always get <code>1</code> back. That&rsquo;s because C knows that when we retrieve data pointed to by a pointer to an integer (i.e. <code>int*</code>) it needs to read 4 bytes! We instead need to &lsquo;force&rsquo; it to just read the first one because that&rsquo;s the one &rsquo;telling&rsquo; us about the machine&rsquo;s endianness! We can do so if we &rsquo;lie&rsquo; and say that the address contained in <code>ptr_x</code> is instead pointing to a single byte (i.e. a <code>char</code>). That&rsquo;s what we accomplish with a <em>type cast</em> like <code>(char*) ptr_x</code>. After casting the pointer we just need to <em>dereference</em> it (i.e. get its value) with <code>*</code> and see what we get back.</p>
<p>According to the diagram above we can easily see how, if we retrieve the first byte and it&rsquo;s a <code>1</code> we on a little endian machine and, if it&rsquo;s a <code>0</code>, we&rsquo;re instead on a big endian system. This is exactly what the <em>if clause</em> checks for!</p>
<p>So, even though it looks hard and cryptic you can actually see it&rsquo;s not that complex in the end is it?</p>
<h2 id="go">Go<a hidden class="anchor" aria-hidden="true" href="#go">#</a></h2>
<p>When working with Go we need to bend the language to our will just like with C. The thing is, Go is a bit more stubborn&hellip;</p>
<p>As we&rsquo;ll be playing with types and trying to override some security features that usually prevent things from going berserk we&rsquo;ll need to leverage the <a href="https://pkg.go.dev/unsafe"><code>unsafe</code></a> package.</p>
<p>The idea is pretty much the same as before: we just store <code>1</code> on a 4 byte <code>int</code> and then we define a pointer to said variable. In a normal scenario we would only be capable of defining a pointer to an <code>int</code> (i.e. a <code>*int</code>), but thanks to <code>unsafe</code>&rsquo;s <code>Pointer</code> type we can circumvent that that restriction.</p>
<p>Using that &rsquo;trick&rsquo; we&rsquo;ll instead define a pointer to a <code>byte</code> (i.e. a <code>char</code> in C&rsquo;s lingo) and just take a look at the value contained in that first address. Just like before, the result of the dereference operator (i.e. <code>*</code>) will tell us all we need to know.</p>
<p>Given C&rsquo;s &rsquo;not <code>0</code> is true&rsquo; policy is not as standard in Go we decided to explicitly check whether the returned value is <code>1</code> or not. We also chose to explicitly define <code>px *byte</code> instead of writing it all within the <code>if</code> clause to make things a bit clearer: we feel Go is not as geared towards cryptic expressions as C.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;unsafe&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">x</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">px</span> <span class="o">*</span><span class="kt">byte</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">*</span><span class="nx">px</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Little endian!\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Big endian!\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>If you store that on a file named <code>endianness.go</code> and run the following you&rsquo;ll get your result too:</p>
<pre><code>go run endianness.go
</code></pre>
<p>The idea and memory layout is exactly the same as before!</p>
<h1 id="thats-it">That&rsquo;s it!<a hidden class="anchor" aria-hidden="true" href="#thats-it">#</a></h1>
<p>Well, we did really dig into C&rsquo;s and Go&rsquo;s &lsquo;belly&rsquo; there! Time for a pat in the back :clap:</p>
<hr>
<p>If you have any comments, questions or suggestions, feel free to drop me an email!</p>
<p>Thanks for your time! Hope you found this useful :smile_cat:</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://pcolladosoto.github.io/tags/fundamentals/">fundamentals</a></li>
      <li><a href="https://pcolladosoto.github.io/tags/programming/">programming</a></li>
      <li><a href="https://pcolladosoto.github.io/tags/c/">c</a></li>
      <li><a href="https://pcolladosoto.github.io/tags/go/">go</a></li>
    </ul>

<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Checking a system&#39;s endianness on twitter"
        href="https://twitter.com/intent/tweet/?text=Checking%20a%20system%27s%20endianness&amp;url=https%3a%2f%2fpcolladosoto.github.io%2fposts%2fendianness%2f&amp;hashtags=fundamentals%2cprogramming%2cc%2cgo">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Checking a system&#39;s endianness on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpcolladosoto.github.io%2fposts%2fendianness%2f&amp;title=Checking%20a%20system%27s%20endianness&amp;summary=Checking%20a%20system%27s%20endianness&amp;source=https%3a%2f%2fpcolladosoto.github.io%2fposts%2fendianness%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Checking a system&#39;s endianness on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fpcolladosoto.github.io%2fposts%2fendianness%2f&title=Checking%20a%20system%27s%20endianness">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Checking a system&#39;s endianness on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpcolladosoto.github.io%2fposts%2fendianness%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Checking a system&#39;s endianness on whatsapp"
        href="https://api.whatsapp.com/send?text=Checking%20a%20system%27s%20endianness%20-%20https%3a%2f%2fpcolladosoto.github.io%2fposts%2fendianness%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Checking a system&#39;s endianness on telegram"
        href="https://telegram.me/share/url?text=Checking%20a%20system%27s%20endianness&amp;url=https%3a%2f%2fpcolladosoto.github.io%2fposts%2fendianness%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://pcolladosoto.github.io/">Just another Jedi...</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
