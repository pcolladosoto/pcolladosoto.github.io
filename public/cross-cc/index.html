<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Cross Compiling stuff with Docker | Just another Jedi...</title>
<meta name="keywords" content="">
<meta name="description" content="Do we really have to compile stuff in the 21st century? Short answer: yes. Long answer: it really depends on the context you develop programs in, but chances are you&rsquo;ll end up running into compilation at some point&hellip;
Old school programming languages like C and C&#43;&#43; are compiled languages, that is, their source files (*.c and *.cpp, respectively) must be compiled (and probably linked and whatnot) into an executable that can later be executed.">
<meta name="author" content="Pablo Collado Soto">
<link rel="canonical" href="https://pcolladosoto.github.io/cross-cc/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7140587df96a2b1a49eb723fa7063dc0c641a6cb638f3140e8d3beb4deae4f5c.css" integrity="sha256-cUBYfflqKxpJ63I/pwY9wMZBpstjjzFA6NO&#43;tN6uT1w=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://pcolladosoto.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://pcolladosoto.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://pcolladosoto.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://pcolladosoto.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://pcolladosoto.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Cross Compiling stuff with Docker" />
<meta property="og:description" content="Do we really have to compile stuff in the 21st century? Short answer: yes. Long answer: it really depends on the context you develop programs in, but chances are you&rsquo;ll end up running into compilation at some point&hellip;
Old school programming languages like C and C&#43;&#43; are compiled languages, that is, their source files (*.c and *.cpp, respectively) must be compiled (and probably linked and whatnot) into an executable that can later be executed." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://pcolladosoto.github.io/cross-cc/" /><meta property="og:image" content="https://pcolladosoto.github.io/assets/me.png"/><meta property="article:section" content="" />
<meta property="article:published_time" content="2023-05-09T13:18:51+02:00" />
<meta property="article:modified_time" content="2023-05-09T13:18:51+02:00" /><meta property="og:site_name" content="Just another Jedi..." />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://pcolladosoto.github.io/assets/me.png"/>

<meta name="twitter:title" content="Cross Compiling stuff with Docker"/>
<meta name="twitter:description" content="Do we really have to compile stuff in the 21st century? Short answer: yes. Long answer: it really depends on the context you develop programs in, but chances are you&rsquo;ll end up running into compilation at some point&hellip;
Old school programming languages like C and C&#43;&#43; are compiled languages, that is, their source files (*.c and *.cpp, respectively) must be compiled (and probably linked and whatnot) into an executable that can later be executed."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Cross Compiling stuff with Docker",
      "item": "https://pcolladosoto.github.io/cross-cc/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Cross Compiling stuff with Docker",
  "name": "Cross Compiling stuff with Docker",
  "description": "Do we really have to compile stuff in the 21st century? Short answer: yes. Long answer: it really depends on the context you develop programs in, but chances are you\u0026rsquo;ll end up running into compilation at some point\u0026hellip;\nOld school programming languages like C and C++ are compiled languages, that is, their source files (*.c and *.cpp, respectively) must be compiled (and probably linked and whatnot) into an executable that can later be executed.",
  "keywords": [
    
  ],
  "articleBody": "Do we really have to compile stuff in the 21st century? Short answer: yes. Long answer: it really depends on the context you develop programs in, but chances are you’ll end up running into compilation at some point…\nOld school programming languages like C and C++ are compiled languages, that is, their source files (*.c and *.cpp, respectively) must be compiled (and probably linked and whatnot) into an executable that can later be executed. We are by no means experts on the topic of compilation (we still cry from time to time when working with Makefiles), so if you want to read up more on compilation we believe CS Fundamentals to be a good starting point. It uses the gcc toolchain as an example to walk you through the process through which source files become executables, so it’s easy to follow along! However, we might consider writing our own entry on compilation, so stay tuned!\nIn any case, the main takeaway is that when we deal with compiled languages, we need to compile source code into an executable. In doing so, we usually leverage a compiler and a linker. What’s more, we can (very broadly) classify generated executables in two categories:\nDynamic Executables: Some of the executable’s dependencies (such as external libraries) are not included in the executable itself. Let’s say it knows where to find these dependencies somewhere on the system it’s running on. The catch is, the executable might run on a system where these requirements are not met, thus rendering it useless on said platform… The main advantage of this approach is that the binaries we execute are smaller and that shared code is reused by various programs.\nStatic Executables: These contain everything they need to run: no external dependencies required. These binaries will be a bit larger than their counterparts, but they will run no matter the environment they’re in. That’s why we favour these when targeting embedded systems if we can spare the extra storage.\nWe believe it’s also important to note that modern languages such as go and rust are also compiled: don’t think compilation is just a blast form the past! The following sections will deal with cross-compilation: the process of compiling stuff on a machine with a given architecture for a machine running a different one. What’s more, we’ll carry out this compilation within Docker containers so that the process is platform agnostic. Aren’t containers cool?\nOur example program: WireGuard WireGuard is a L3 VPN implementation we have commonly found incredibly useful. We’ll write an entry explaining how to get it up and running along with some ideas of what you can do with it, in case you’d be interested on that… The thing is, there was nothing like a packaged version of WireGuard or anything of that nature for the embedded system we wanted to run things on. That’s why we had to compile everything from source. In this occasion, we will try to cross-compile everything from a machine running macOS. The need for cross-compilation arises because, even though the machine does have a full kernel running just above the hardware, it does lack a lot of the tools and facilities one could expect on a normal desktop computer. Thus, we decided to compile all the necessary tools as static binaries so that we didn’t depend on libraries we would likely be missing on the embedded device.\nThis will give you a taste of what the process is like and the good thing is we will have to work with two different languages: C and go. You can find a nice discussion on cross-compilation here. We encourage you not to mistake the forest for the trees: the discussion that follows is not only applicable to the compilation of WireGuard. Even though some steps are very tied to it (like the modification of the Makefile), always remember that adapting the process to any program would only be a matter of pulling the necessary requirements and following that program’s compilation instructions, nothing more.\nWhat we need to compile We can regard WireGuard as the superposition of a couple of tools:\nWireGuard: This would be the L3 VPN implementation. On linux-based systems WireGuard is intended to run as a kernel module. In other words, WireGuard runs within the kernel, not above it on the so called ‘user land’. This provides a ’tight’ integration with linux itself, as well as a better performance when compared to other alternatives such as OpenVPN.\nwg: Most of us interact with WireGuard VPNs through the wg(8) tool. This is what we could regard as a ‘configuration client’ that communicates with the implementation and alters or monitors its state. Even though not strictly needed, we really consider having access to wg a must in order to make our life that much easier.\nOur target As previously stated, we will try to compile WireGuard for it to run on an embedded system running a full-fledged linux 4.14.78 kernel with a Freescale i.MX6 UltraLite CPU. This CPU leverages the armv7l architecture which, in turn, works with a 32-bit instruction set.\nThe above can be summarized into:\nTarget kernel: linux 4.14.78. Target architecture: armv7l (32 bit). This information is crucial: it characterizes the target system we want to generate executables for! With all that out of the way, let’s get down to business!\nCompiling the VPN implementation Even though WireGuard is intended to run as a linux module, we were not brave enough to cross-compile a kernel module (however, we intend to do that at some point :information_desk_person:). That is why we decided to leverage WireGuard’s Go implementation: wireguard-go. Given Go’s principles and the fact that it’s a compiled language it’s fairly easy to leverage a binary on other platforms. By default, binaries produced by Go are static. What’s more, we can easily cross-compile Go code through the use of a couple of environment variables. Please note that you’ll need to have Go installed in order to compile the code. You can see how to do it here.\nGOOS: Controls the kernel to build against. Possible values are linux for linux-based systems, darwin for macOS and windows for Windows systems.\nGOARCH: Controls the architecture to build against. Possible values are 836, amd64, arm, arm64…\nAll possible combinations can be derived from the output provided by:\ngo tool dist list -json Given the specifications of our target system, we have chosen values linux and arm for GOOS and GOARCH, respectively.\nAs specified on the wireguard-go repository, one just needs to run the following commands to build the static wireguard-go binary. Notice we have interleaved the definition of both environment variables:\n# Clone the wireguard-go repo git clone https://git.zx2c4.com/wireguard-go # Move into that directory cd wireguard-go # Define variables for cross-compilation export GOOS=linux export GOARCH=arm # Compile the code make The previous instructions will generate the wireguard-go binary which is a static binary implementing the VPN implementation. Once that’s ready, we just need to move the binary somewhere within the PATH of the target system (like /bin for instance):\nscp wireguard-go @:/bin This will allow us to run the generated program by just typing wireguard-go on the target system. That wasn’t too bad was it?\nCompiling the wg utility The wg utility source code can be found on the wireguard-tools repository. Unlike in the previous case, we now have to deal with C code…\nThe need for Docker We are working on macOS and we feel a lot more comfortable working on a linux-based distribution for these types of tasks. That’s why we have decided to leverage Docker: we will spin up a Ubuntu container and install all necessary dependencies on to it to then carry out the compilation in it. The great things about this approach is are:\nThe host system remains clean: we needn’t worry about leaving behind unnecessary packages that will just bloat our installed package lists. The container is reproducible: we can follow these steps on any platform capable of running docker. We can easily share the setup with anybody who wants it: we can either provide the Dockerfile or just upload the resulting image to Docker Hub. It’s true that the best practice is to provide a Dockefile that can be leveraged to generate a Docker image. However, these Dockerfiles can sometimes get a bit ‘magical’ and people reading them might mistake the forest for the trees at some point… That’s why we are providing the following instructions which anyone can use to turn a vanilla (i.e. stock) Ubuntu docker image into a cross-compilation station. Just be sure to run the following to start up a container running Ubuntu:\ndocker run -it ubuntu bash Once that is up and running (don’t forget the -it flags or the container will just terminate), just run the following in order:\n# Get necessary tools: # curl: Client for transferring data with several protocols, including HTTP. # git: Git VCS for pulling code repositories. # vim: Terminal text editor in case we need to perform some minor tweaks. # libelf-dev: Development files for libelf. # libelf: Library for reading and writing ELF files. # build-essential: Collection of tools for building codes, such as gcc, make... # pkg-config: Manage compile and link flags. # gcc-arm-linux-gnueabi: C compiler for ARM architectures. # binutils-arm-linux-gnueabi: Binary utilities for ARM targets. root@container# apt update \u0026\u0026 apt install curl git vim libelf-dev build-essential pkg-config gcc-arm-linux-gnueabi binutils-arm-linux-gnueabi # Get the source code to compile root@container# git clone https://git.zx2c4.com/wireguard-tools.git # Navigate to the wireguard-tools directory root@container# cd wireguard-tools/src Given compilation is controlled by a Makefile, we have decided to ’tweak’ it a bit so that we generate a static binary. We can do so by adding the following line at the beginning of the file:\nvim# LDFLAGS = -static We also need to alter the compiler we are to use. We commonly use gcc, but as we are cross-compiling the code for ARM platforms we need to leverage the arm-linux-gnueabi-gcc compiler we have just downloaded. We can instruct the Makefile to use said compiler by adding the following line at the beginning too:\nvim# CC = arm-linux-gnueabi-gcc The thing is, if we run make to try and compile the code it will fail… The cause behind the error is we are using the glibc implementation by default and it cannot statically compile some functions such as sockaddr(), which wg relies on. So what can we do?\nWe settled on leveraging a different C implementation: Musl. Instead of just pulling the code, we decided to get a release from musl.cc. We can pull the necessary release with:\n# Pull the necessary release: # arm-*: Musl C implementation for ARM targets. # *-cross: This is a cross compiler. root@container# curl -o musl.tar.gz https://musl.cc/arm-linux-musleabi-cross.tgz # Decompress the distribution and remove the compressed file root@container# tar -xvf musl.tar.gz \u0026\u0026 rm musl.tar.gz # Move the required compiler leveraging Musl to somewhere on the PATH (like /bin). root@container# cp -r arm-linux-musleabi-cross/ /bin # Update the PATH root@container# export PATH=$PATH:/bin/arm-linux-musleabi-cross/bin Now that the compiler is available, we just need to change the compiler on the Makefile as defined by the CC variable:\nvim# CC = arm-linux-musleabi-gcc After all this changing around, the Makefile is pretty much like the original. We have just added the following as line 40 and line 41, respectively:\nvim# LDFLAGS = -static vim# CC = arm-linux-musleabi-gcc Now, we can issue make and everything should compile correctly. However, doing all this stuff every time we want to generate a binary is very tiresome. We’ll now see how we can summarize a big chunk of the process with the help of a Dockerfile.\nSumming it all up: the Dockerfile The steps we followed above regarding the installation of dependencies for compilation can be taken care of with a Dockerfile. This allows us to use the docker build command to generate a docker image that’s ready to be used. We just need to run the following from within the directory containing the Dockerfile:\n# Build the image. It will be named arm-cross-compiler docker build -t arm-cross-compiler . The Dockerfile itself is:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 FROM ubuntu # Install the necessary dependencies and purge stuff afterwards RUN apt-get update \\ \u0026\u0026 DEBIAN_FRONTEND=noninteractive apt-get install -y \\ curl \\ git \\ vim \\ libelf-dev \\ build-essential \\ pkg-config \\ gcc-arm-linux-gnueabi \\ binutils-arm-linux-gnueabi \\ \u0026\u0026 apt-get clean \\ \u0026\u0026 rm -rf /var/lib/apt/lists/* # Pull Musl on a single instruction to create a layer RUN curl -o musl.tar.gz https://musl.cc/arm-linux-musleabi-cross.tgz \\ \u0026\u0026 tar -xvf musl.tar.gz \\ \u0026\u0026 rm musl.tar.gz # Install Musl RUN cp -r arm-linux-musleabi-cross /bin # Update PATH ENV PATH=\"${PATH}:/bin/arm-linux-musleabi-cross/bin\" Once that’s built, we can just carry out the same as above with: docker run -it –rm arm-cross-compiler\n# Now we just need to pull the code... root@container# git clone https://git.zx2c4.com/wireguard-tools.git # Navigate into it root@container# cd wireguard-tools/src # Add the lines specified above! root@container# vim Makefile # And compile! This will generate `wg` on the current directory. root@container# make Now, if you run make again you should be greeted by a statically compiled wg file that can be leveraged on any system! On top of that, we will also copy the wireguard-tools/src/wg-quick/linux.bash script, as it allows us to comfortably control WireGuard on the target system. We can pull that file from within the container with docker cp if we didn’t pass a volume to it.\nWe just need to move these two files somewhere within the PATH on the target system like with the VPN implementation:\n# Copy the wg tool implementation to the target system scp wg @:/bin # Make the script executable chmod +x src/wg-quick/linux.bash # And copy it to the target machine scp src/wg-quick/linux.bash @:/bin/wg-quick With that, we would have the wg utility up and running on the target system!\nSetting up WireGuard on the target system We just need to move the generated certificate file for the target system to /etc/wireguard so that it can be detected by wg-quick. Assuming said file is wg0.conf we just need to run:\n# Note prompt '$' denotes the local system and '\u003e' the remote one. # Log into the remote system $ ssh @ # Make the /etc/wireguard directory \u003e mkdir -p /etc/wireguard # And move the configuration there $ scp wg0.conf @:/wtc/wireguard With that, we should be able to run wg-quick up wg0.conf from within the remote system and we should see an interface output similar to:\n\u003e ip link 1: lo: mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2: eth0: mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000 link/ether f8:dc:7a:3a:a0:be brd ff:ff:ff:ff:ff:ff 3: sit0@NONE: mtu 1480 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/sit 0.0.0.0 brd 0.0.0.0 4: wlan0: mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000 link/ether 00:25:ca:33:80:b3 brd ff:ff:ff:ff:ff:ff 5: wg0: mtu 1420 qdisc pfifo_fast state UNKNOWN mode DEFAULT group default qlen 500 link/none That implies that everything is working fine! We have both a wg0 interface and the sit0 one. This hints that the implementation relies on a some kind of IPv4/IPv4 tunnel…\nExtending the above When working with the target embedded system we got in touch with the manufacturer to try and get some custom built libraries for the machine. These would allow us to interact with the system’s hardware so that we could incorporate the data it generated into our own programs. The manufacturer provided both the original C++ libraries as well as bindings for go, the language we are developing our software in. The thing is, this also called for some cross-compilation with a brand-new twist. Given the structure of the bindings, we had to make the go code interact with the C++ one through the cgo package.\nJust like before, we decided to write a Dockerfile that would allow us to carry all the process out within a container. We now need to compile go code form within the container, which added a new step to the Dockerfile: we need to install go and all its tools (such as the compiler). We also had to load the original C++ libraries into the container and then tell go where to find them. After a lot of trial and error we finally came up with the following:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 FROM ubuntu:20.04 # Get APT dependencies: # curl: Allows us to download the Go distribution RUN apt-get update \\ \u0026\u0026 DEBIAN_FRONTEND=noninteractive apt-get install -y \\ curl \\ \u0026\u0026 apt-get clean \\ \u0026\u0026 rm -rf /var/lib/apt/lists/* # Get Go RUN curl -o go.tar.gz https://dl.google.com/go/go1.17.3.linux-amd64.tar.gz \u0026\u0026 \\ tar -C /usr/local -xzf go.tar.gz \u0026\u0026 \\ rm -rf go.tar.gz # Pull the cross compiler in COPY ./toolchain/gcc-arm-9.2-2019.12-x86_64-arm-none-linux-gnueabihf /bin/gcc-arm-toolchain # Get the header files and the compiled library too COPY ./toolchain/manufacturer_provided_files/lib /usr/lib/emod COPY ./toolchain/manufacturer_provided_files/include /usr/include/emod # Update the path so as to include Go ENV PATH=\"/usr/local/go/bin:${PATH}\" # Update compilation vars for GO: # Target architecture to compile against ENV GOARCH=\"arm\" # Target OS to compile against ENV GOOS=\"linux\" # Enable Go's interation with pure C code ENV CGO_ENABLED=\"1\" # Tell Go which compiler to use for C code (i.e. the gcc ARM cross-compiler we loaded before) ENV CC=\"/bin/gcc-arm-toolchain/bin/arm-none-linux-gnueabihf-gcc\" # Tell the C compiler where to look for headers (i.e. *.hpp and *.h files). ENV CGO_CFLAGS=\"-I/usr/include/emod/\" # tell the C compiler where to look for libraries (i.e. *.a files) ENV CGO_LDFLAGS=\"-L/usr/lib/emod/\" In order to leverage the above, we need to run the following command from a directory whose contents resemble:\n1 2 3 4 5 6 7 . | + --- Dockerfile + --- + toolchain/ | + --- manufacturer_provided_files/ + --- gcc-arm-9.2-2019.12-x86_64-arm-none-linux-gnueabihf/ The contents of the toolchain directory are:\nGNU Toolchain for the ARM Cortex-A Family: This directory contains the C++ compiler we point go to through the CC environment variable. It will be in charge of compiling the C++ code the go bindings depend on. It can be downloaded here. You can also browse the different toolchains here. Once downloaded, you will have to decompress them with tar -xzf gcc-arm-9.2-2019.12-x86_64-arm-none-linux-gnueabihf.tar.xz. The resulting directory is what needs to be stored under the toolchain/ directory.\nOriginal Manufacturer Libs: These are, as the name implies, provided by the manufacturer. You’ll also need to decompress them (probably with tar -xzf too) and place them under the toolchain/ directory as well.\nFinally, we can cd into the directory outlined above and run:\ndocker build -t cc-embedded . This will generate the cc-embedded docker image that can be run with:\ndocker run --rm -it cc-embedded bash Note the --rm flag will remove the container once we close the session (so as to keep our docker daemon tidy) and the -it flags will keep STDIN attached and allocate a pseudo-TTY, respectively. This prevent the container from staring and closing, which would be the case if we did not interact with the provided shell interactively. We also recommend mounting code we want to compile into the container with the help of volumes.\nFor instance, if we pull the examples from bitbucket.org:pickdata-fw/emod_controller_binding_go, we can mount the examples into the container (assuming the repository is cloned as go_bindings_repo) with:\ndocker run --rm -it -v /path/to/go_bindings_repo:/repo cc-embedded bash The above would expose the repository within the container on the /repo directory. Once within it, we can just cd into an example and run:\n# Create a module for the example go mod init example/foo # Get the module's requirements go mod tidy # And build it! go build As all the environment variables have been specified at the time of the image’s creation, we can really simplify the building process! What’s more, as the repository is mounted as a volume, the build process will generate the executable within our host’s directory, no need to run docker cp anymore :sunglasses:\nAll in all, given these general ideas we believe it is feasible to adapt this process to any project you might be working on!\nIf you have any comments, questions or suggestions, feel free to drop me an email!\nThanks for your time! Hope you found this useful :smile_cat:\n",
  "wordCount" : "3410",
  "inLanguage": "en",
  "datePublished": "2023-05-09T13:18:51+02:00",
  "dateModified": "2023-05-09T13:18:51+02:00",
  "author":{
    "@type": "Person",
    "name": "Pablo Collado Soto"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://pcolladosoto.github.io/cross-cc/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Just another Jedi...",
    "logo": {
      "@type": "ImageObject",
      "url": "https://pcolladosoto.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://pcolladosoto.github.io/" accesskey="h" title="Just another Jedi... (Alt + H)">Just another Jedi...</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://pcolladosoto.github.io/">Home</a></div>
    <h1 class="post-title">
      Cross Compiling stuff with Docker
    </h1>
    <div class="post-meta"><span title='2023-05-09 13:18:51 +0200 CEST'>09/05/9056</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;3410 words&nbsp;·&nbsp;Pablo Collado Soto

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#our-example-program-wireguard">Our example program: WireGuard</a>
      <ul>
        <li><a href="#what-we-need-to-compile">What we need to compile</a></li>
        <li><a href="#our-target">Our target</a></li>
        <li><a href="#setting-up-wireguard-on-the-target-system">Setting up WireGuard on the target system</a></li>
      </ul>
    </li>
    <li><a href="#extending-the-above">Extending the above</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="do-we-really-have-to-compile-stuff-in-the-21st-century">Do we really have to compile stuff in the 21st century?<a hidden class="anchor" aria-hidden="true" href="#do-we-really-have-to-compile-stuff-in-the-21st-century">#</a></h1>
<p>Short answer: yes. Long answer: it really depends on the context you develop programs in, but chances are you&rsquo;ll end up running into compilation at some point&hellip;</p>
<p>Old school programming languages like <code>C</code> and <code>C++</code> are <em>compiled languages</em>, that is, their source files (<code>*.c</code> and <code>*.cpp</code>, respectively) must be <em>compiled</em> (and probably <em>linked</em> and whatnot) into an executable that can later be executed. We are by no means experts on the topic of compilation (we still cry from time to time when working with <code>Makefile</code>s), so if you want to read up more on compilation we believe <a href="https://www.cs-fundamentals.com/c-programming/how-to-compile-c-program-using-gcc">CS Fundamentals</a> to be a good starting point. It uses the <code>gcc</code> toolchain as an example to walk you through the process through which source files become executables, so it&rsquo;s easy to follow along! However, we might consider writing our own entry on compilation, so stay tuned!</p>
<p>In any case, the main takeaway is that when we deal with compiled languages, we need to <em>compile</em> source code into an executable. In doing so, we usually leverage a <em>compiler</em> and a <em>linker</em>. What&rsquo;s more, we can (very broadly) classify generated executables in two categories:</p>
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Library_(computing)#Shared_libraries"><em>Dynamic Executables</em></a>: Some of the executable&rsquo;s dependencies (such as external libraries) <strong>are not</strong> included in the executable itself. Let&rsquo;s say it <em>knows</em> where to find these dependencies somewhere on the system it&rsquo;s running on. The catch is, the executable <em>might</em> run on a system where these requirements are not met, thus rendering it useless on said platform&hellip; The main advantage of this approach is that the binaries we execute are smaller and that shared code is reused by various programs.</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Static_library"><em>Static Executables</em></a>: These contain <strong>everything</strong> they need to run: no external dependencies required. These binaries will be a bit larger than their counterparts, but they will run no matter the environment they&rsquo;re in. That&rsquo;s why we favour these when targeting embedded systems if we can spare the extra storage.</p>
</li>
</ul>
<p>We believe it&rsquo;s also important to note that modern languages such as <code>go</code> and <code>rust</code> are also compiled: don&rsquo;t think compilation is just a blast form the past! The following sections will deal with <em>cross-compilation</em>: the process of compiling stuff on a machine with a given architecture for a machine running a different one. What&rsquo;s more, we&rsquo;ll carry out this compilation within <em>Docker</em> containers so that the process is platform agnostic. Aren&rsquo;t containers cool?</p>
<h2 id="our-example-program-wireguard">Our example program: WireGuard<a hidden class="anchor" aria-hidden="true" href="#our-example-program-wireguard">#</a></h2>
<p><a href="https://www.wireguard.com"><em>WireGuard</em></a> is a <em>L3 VPN</em> implementation we have commonly found incredibly useful. We&rsquo;ll write an entry explaining how to get it up and running along with some ideas of what you can do with it, in case you&rsquo;d be interested on that&hellip; The thing is, there was nothing like a packaged version of <em>WireGuard</em> or anything of that nature for the embedded system we wanted to run things on. That&rsquo;s why we had to compile everything from source. In this occasion, we will try to <em>cross-compile</em> everything from a machine running <em>macOS</em>. The need for <em>cross-compilation</em> arises because, even though the machine does have a full kernel running just above the hardware, it does lack a lot of the tools and facilities one could expect on a normal desktop computer. Thus, we decided to compile all the necessary tools as <a href="https://en.wikipedia.org/wiki/Static_library"><em>static binaries</em></a> so that we didn&rsquo;t depend on libraries we would likely be missing on the embedded device.</p>
<p>This will give you a taste of what the process is like and the good thing is we will have to work with two different languages: <code>C</code> and <code>go</code>. You can find a nice discussion on <em>cross-compilation</em> <a href="https://jensd.be/1126/linux/cross-compiling-for-arm-or-aarch64-on-debian-or-ubuntu">here</a>. We encourage you not to mistake the forest for the trees: the discussion that follows <strong>is not</strong> only applicable to the compilation of <em>WireGuard</em>. Even though some steps are very tied to it (like the modification of the <code>Makefile</code>), always remember that adapting the process to any program would only be a matter of pulling the necessary requirements and following that program&rsquo;s compilation instructions, nothing more.</p>
<h3 id="what-we-need-to-compile">What we need to compile<a hidden class="anchor" aria-hidden="true" href="#what-we-need-to-compile">#</a></h3>
<p>We can regard <em>WireGuard</em> as the superposition of a couple of tools:</p>
<ul>
<li>
<p><em>WireGuard</em>: This would be the <em>L3 VPN</em> implementation. On <em>linux</em>-based systems <em>WireGuard</em> is intended to run as a kernel module. In other words, <em>WireGuard</em> runs <strong>within</strong> the kernel, not above it on the so called &lsquo;user land&rsquo;. This provides a &rsquo;tight&rsquo; integration with <em>linux</em> itself, as well as a better performance when compared to other alternatives such as <em>OpenVPN</em>.</p>
</li>
<li>
<p><em>wg</em>: Most of us interact with <em>WireGuard VPN</em>s through the <a href="https://git.zx2c4.com/wireguard-tools/about/src/man/wg.8"><code>wg(8)</code></a> tool. This is what we could regard as a &lsquo;configuration client&rsquo; that communicates with the implementation and alters or monitors its state. Even though not strictly needed, we really consider having access to <code>wg</code> a must in order to make our life that much easier.</p>
</li>
</ul>
<h3 id="our-target">Our target<a hidden class="anchor" aria-hidden="true" href="#our-target">#</a></h3>
<p>As previously stated, we will try to compile <em>WireGuard</em> for it to run on an embedded system running a full-fledged <em>linux 4.14.78</em> kernel with a <em>Freescale i.MX6 UltraLite</em> CPU. This CPU leverages the <em>armv7l</em> architecture which, in turn, works with a <em>32-bit</em> instruction set.</p>
<p>The above can be summarized into:</p>
<ul>
<li>Target kernel: <em>linux 4.14.78</em>.</li>
<li>Target architecture: <em>armv7l</em> (<em>32 bit</em>).</li>
</ul>
<p>This information is crucial: it characterizes the target system we want to generate executables for! With all that out of the way, let&rsquo;s get down to business!</p>
<h4 id="compiling-the-vpn-implementation">Compiling the VPN implementation<a hidden class="anchor" aria-hidden="true" href="#compiling-the-vpn-implementation">#</a></h4>
<p>Even though <em>WireGuard</em> is intended to run as a <em>linux</em> module, we were not brave enough to cross-compile a kernel module (however, we intend to do that at some point :information_desk_person:). That is why we decided to leverage <em>WireGuard</em>&rsquo;s <em>Go</em> implementation: <a href="https://git.zx2c4.com/wireguard-go/about/"><code>wireguard-go</code></a>. Given <em>Go</em>&rsquo;s principles and the fact that it&rsquo;s a compiled language it&rsquo;s fairly easy to leverage a binary on other platforms. By default, binaries produced by <em>Go</em> are <em>static</em>. What&rsquo;s more, we can easily <em>cross-compile Go</em> code through the use of a couple of environment variables. Please note that you&rsquo;ll need to have <em>Go</em> installed in order to compile the code. You can see how to do it <a href="https://golang.org/doc/install">here</a>.</p>
<ol>
<li>
<p><code>GOOS</code>: Controls the kernel to build against. Possible values are <code>linux</code> for <em>linux</em>-based systems, <code>darwin</code> for <em>macOS</em> and <code>windows</code> for <em>Windows</em> systems.</p>
</li>
<li>
<p><code>GOARCH</code>: Controls the architecture to build against. Possible values are <code>836</code>, <code>amd64</code>, <code>arm</code>, <code>arm64</code>&hellip;</p>
</li>
</ol>
<p>All possible combinations can be derived from the output provided by:</p>
<pre><code>go tool dist list -json
</code></pre>
<p>Given the specifications of our target system, we have chosen values <code>linux</code> and <code>arm</code> for <code>GOOS</code> and <code>GOARCH</code>, respectively.</p>
<p>As specified on the <code>wireguard-go</code> repository, one just needs to run the following commands to build the <em>static</em> <code>wireguard-go</code> binary. Notice we have interleaved the definition of both environment variables:</p>
<pre><code># Clone the wireguard-go repo
git clone https://git.zx2c4.com/wireguard-go

# Move into that directory
cd wireguard-go

# Define variables for cross-compilation
export GOOS=linux
export GOARCH=arm

# Compile the code
make
</code></pre>
<p>The previous instructions will generate the <code>wireguard-go</code> binary which is a <em>static</em> binary implementing the <em>VPN implementation</em>. Once that&rsquo;s ready, we just need to move the binary somewhere within the <code>PATH</code> of the target system (like <code>/bin</code> for instance):</p>
<pre><code>scp wireguard-go &lt;username&gt;@&lt;target-ip&gt;:/bin
</code></pre>
<p>This will allow us to run the generated program by just typing <code>wireguard-go</code> on the target system. That wasn&rsquo;t too bad was it?</p>
<h4 id="compiling-the-wg-utility">Compiling the wg utility<a hidden class="anchor" aria-hidden="true" href="#compiling-the-wg-utility">#</a></h4>
<p>The <code>wg</code> utility source code can be found on the <a href="https://git.zx2c4.com/wireguard-tools/about/"><code>wireguard-tools</code></a> repository. Unlike in the previous case, we now have to deal with <code>C</code> code&hellip;</p>
<h5 id="the-need-for-docker">The need for Docker<a hidden class="anchor" aria-hidden="true" href="#the-need-for-docker">#</a></h5>
<p>We are working on <em>macOS</em> and we feel a lot more comfortable working on a <em>linux</em>-based distribution for these types of tasks. That&rsquo;s why we have decided to leverage <em>Docker</em>: we will spin up a <em>Ubuntu</em> container and install all necessary dependencies on to it to then carry out the compilation in it. The great things about this approach is are:</p>
<ul>
<li>The host system remains clean: we needn&rsquo;t worry about leaving behind unnecessary packages that will just bloat our installed package lists.</li>
<li>The container is reproducible: we can follow these steps on any platform capable of running <em>docker</em>.</li>
<li>We can easily share the setup with anybody who wants it: we can either provide the <code>Dockerfile</code> or just upload the resulting image to <em>Docker Hub</em>.</li>
</ul>
<p>It&rsquo;s true that the best practice is to provide a <code>Dockefile</code> that can be leveraged to generate a <em>Docker image</em>. However, these <code>Dockerfile</code>s can sometimes get a bit &lsquo;magical&rsquo; and people reading them might mistake the forest for the trees at some point&hellip; That&rsquo;s why we are providing the following instructions which anyone can use to turn a <em>vanilla</em> (i.e. stock) <em>Ubuntu docker image</em> into a <em>cross-compilation</em> station. Just be sure to run the following to start up a container running <em>Ubuntu</em>:</p>
<pre><code>docker run -it ubuntu bash
</code></pre>
<p>Once that is up and running (don&rsquo;t forget the <code>-it</code> flags or the container will just terminate), just run the following in order:</p>
<pre><code># Get necessary tools:
    # curl: Client for transferring data with several protocols, including HTTP.
    # git: Git VCS for pulling code repositories.
    # vim: Terminal text editor in case we need to perform some minor tweaks.
    # libelf-dev: Development files for libelf.
        # libelf: Library for reading and writing ELF files.
    # build-essential: Collection of tools for building codes, such as gcc, make...
    # pkg-config: Manage compile and link flags.
    # gcc-arm-linux-gnueabi: C compiler for ARM architectures.
    # binutils-arm-linux-gnueabi: Binary utilities for ARM targets.
root@container# apt update &amp;&amp; apt install curl git vim libelf-dev build-essential pkg-config gcc-arm-linux-gnueabi binutils-arm-linux-gnueabi

# Get the source code to compile
root@container# git clone https://git.zx2c4.com/wireguard-tools.git

# Navigate to the wireguard-tools directory
root@container# cd wireguard-tools/src
</code></pre>
<p>Given compilation is controlled by a <code>Makefile</code>, we have decided to &rsquo;tweak&rsquo; it a bit so that we generate a static binary. We can do so by adding the following line at the beginning of the file:</p>
<pre><code>vim# LDFLAGS = -static
</code></pre>
<p>We also need to alter the compiler we are to use. We commonly use <code>gcc</code>, but as we are cross-compiling the code for <em>ARM</em> platforms we need to leverage the <code>arm-linux-gnueabi-gcc</code> compiler we have just downloaded. We can instruct the <code>Makefile</code> to use said compiler by adding the following line at the beginning too:</p>
<pre><code>vim# CC = arm-linux-gnueabi-gcc
</code></pre>
<p>The thing is, if we run <code>make</code> to try and compile the code it <strong>will fail</strong>&hellip; The cause behind the error is we are using the <code>glibc</code> implementation by default and it <strong>cannot</strong> statically compile some functions such as <code>sockaddr()</code>, which <code>wg</code> relies on. So what can we do?</p>
<p>We settled on leveraging a different <code>C</code> implementation: <a href="https://musl.libc.org"><em>Musl</em></a>. Instead of just pulling the code, we decided to get a release from <a href="https://musl.cc/#binaries"><code>musl.cc</code></a>. We can pull the necessary release with:</p>
<pre><code># Pull the necessary release:
    # arm-*: Musl C implementation for ARM targets.
    # *-cross: This is a cross compiler.
root@container# curl -o musl.tar.gz https://musl.cc/arm-linux-musleabi-cross.tgz

# Decompress the distribution and remove the compressed file
root@container# tar -xvf musl.tar.gz &amp;&amp; rm musl.tar.gz

# Move the required compiler leveraging Musl to somewhere on the PATH (like /bin).
root@container# cp -r arm-linux-musleabi-cross/ /bin

# Update the PATH
root@container# export PATH=$PATH:/bin/arm-linux-musleabi-cross/bin
</code></pre>
<p>Now that the compiler is available, we just need to change the compiler on the <code>Makefile</code> as defined by the <code>CC</code> variable:</p>
<pre><code>vim# CC = arm-linux-musleabi-gcc
</code></pre>
<p>After all this changing around, the <code>Makefile</code> is pretty much like the original. We have just added the following as <code>line 40</code> and <code>line 41</code>, respectively:</p>
<pre><code>vim# LDFLAGS = -static
vim# CC = arm-linux-musleabi-gcc
</code></pre>
<p>Now, we can issue <code>make</code> and everything should compile correctly. However, doing all this stuff every time we want to generate a binary is very tiresome. We&rsquo;ll now see how we can summarize a big chunk of the process with the help of a <code>Dockerfile</code>.</p>
<h5 id="summing-it-all-up-the-dockerfile">Summing it all up: the Dockerfile<a hidden class="anchor" aria-hidden="true" href="#summing-it-all-up-the-dockerfile">#</a></h5>
<p>The steps we followed above regarding the installation of dependencies for compilation can be taken care of with a <code>Dockerfile</code>. This allows us to use the <code>docker build</code> command to generate a <em>docker image</em> that&rsquo;s ready to be used. We just need to run the following from within the directory containing the <code>Dockerfile</code>:</p>
<pre><code># Build the image. It will be named arm-cross-compiler
docker build -t arm-cross-compiler .
</code></pre>
<p>The <code>Dockerfile</code> itself is:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> ubuntu</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># Install the necessary dependencies and purge stuff afterwards</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> <span class="nv">DEBIAN_FRONTEND</span><span class="o">=</span>noninteractive apt-get install -y <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        curl <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        git <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        vim <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        libelf-dev <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        build-essential <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        pkg-config <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        gcc-arm-linux-gnueabi <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        binutils-arm-linux-gnueabi <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> apt-get clean <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> rm -rf /var/lib/apt/lists/*<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># Pull Musl on a single instruction to create a layer</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> curl -o musl.tar.gz https://musl.cc/arm-linux-musleabi-cross.tgz <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> tar -xvf musl.tar.gz <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> rm musl.tar.gz<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># Install Musl</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> cp -r arm-linux-musleabi-cross /bin<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># Update PATH</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="si">${</span><span class="nv">PATH</span><span class="si">}</span><span class="s2">:/bin/arm-linux-musleabi-cross/bin&#34;</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Once that&rsquo;s built, we can just carry out the same as above with:
docker run -it &ndash;rm arm-cross-compiler</p>
<pre><code># Now we just need to pull the code...
root@container# git clone https://git.zx2c4.com/wireguard-tools.git

# Navigate into it
root@container# cd wireguard-tools/src

# Add the lines specified above!
root@container# vim Makefile

# And compile! This will generate `wg` on the current directory.
root@container# make
</code></pre>
<p>Now, if you run <code>make</code> again you should be greeted by a statically compiled <code>wg</code> file that can be leveraged on any system! On top of that, we will also copy the <code>wireguard-tools/src/wg-quick/linux.bash</code> script, as it allows us to comfortably control <em>WireGuard</em> on the target system. We can pull that file from within the container with <a href="https://docs.docker.com/engine/reference/commandline/cp/"><code>docker cp</code></a> if we didn&rsquo;t pass a volume to it.</p>
<p>We just need to move these two files somewhere within the <code>PATH</code> on the target system like with the <em>VPN implementation</em>:</p>
<pre><code># Copy the wg tool implementation to the target system
scp wg &lt;username&gt;@&lt;target-ip&gt;:/bin

# Make the script executable
chmod +x src/wg-quick/linux.bash

# And copy it to the target machine
scp src/wg-quick/linux.bash &lt;username&gt;@&lt;target-ip&gt;:/bin/wg-quick
</code></pre>
<p>With that, we would have the <code>wg</code> utility up and running on the target system!</p>
<h3 id="setting-up-wireguard-on-the-target-system">Setting up WireGuard on the target system<a hidden class="anchor" aria-hidden="true" href="#setting-up-wireguard-on-the-target-system">#</a></h3>
<p>We just need to move the generated certificate file for the target system to <code>/etc/wireguard</code> so that it can be detected by <code>wg-quick</code>. Assuming said file is <code>wg0.conf</code> we just need to run:</p>
<pre><code># Note prompt '$' denotes the local system and '&gt;' the remote one.

# Log into the remote system
$ ssh &lt;username&gt;@&lt;target-ip&gt;

# Make the /etc/wireguard directory
&gt; mkdir -p /etc/wireguard

# And move the configuration there
$ scp wg0.conf &lt;username&gt;@&lt;target-ip&gt;:/wtc/wireguard
</code></pre>
<p>With that, we should be able to run <code>wg-quick up wg0.conf</code> from within the remote system and we should see an interface output similar to:</p>
<pre><code>&gt; ip link
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether f8:dc:7a:3a:a0:be brd ff:ff:ff:ff:ff:ff
3: sit0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/sit 0.0.0.0 brd 0.0.0.0
4: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 00:25:ca:33:80:b3 brd ff:ff:ff:ff:ff:ff
5: wg0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1420 qdisc pfifo_fast state UNKNOWN mode DEFAULT group default qlen 500
    link/none
</code></pre>
<p>That implies that everything is working fine! We have both a <code>wg0</code> interface and the <code>sit0</code> one. This hints that the implementation relies on a some kind of <em>IPv4/IPv4</em> tunnel&hellip;</p>
<h2 id="extending-the-above">Extending the above<a hidden class="anchor" aria-hidden="true" href="#extending-the-above">#</a></h2>
<p>When working with the target embedded system we got in touch with the manufacturer to try and get some custom built libraries for the machine. These would allow us to interact with the system&rsquo;s hardware so that we could incorporate the data it generated into our own programs. The manufacturer provided both the original <code>C++</code> libraries as well as bindings for <code>go</code>, the language we are developing our software in. The thing is, this also called for some cross-compilation with a brand-new twist. Given the structure of the bindings, we had to make the <code>go</code> code interact with the <code>C++</code> one through the <a href="https://pkg.go.dev/cmd/cgo"><code>cgo</code></a> package.</p>
<p>Just like before, we decided to write a <code>Dockerfile</code> that would allow us to carry all the process out within a container. We now need to compile <code>go</code> code form <strong>within the container</strong>, which added a new step to the <code>Dockerfile</code>: we need to install <code>go</code> and all its tools (such as the compiler). We also had to load the original <code>C++</code> libraries into the container and then tell <code>go</code> where to find them. After a lot of trial and error we finally came up with the following:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> ubuntu:20.04</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># Get APT dependencies:</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="c1"># curl: Allows us to download the Go distribution</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> <span class="nv">DEBIAN_FRONTEND</span><span class="o">=</span>noninteractive apt-get install -y <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        curl <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> apt-get clean <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> rm -rf /var/lib/apt/lists/*<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># Get Go</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> curl -o go.tar.gz https://dl.google.com/go/go1.17.3.linux-amd64.tar.gz <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    tar -C /usr/local -xzf go.tar.gz <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    rm -rf go.tar.gz<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># Pull the cross compiler in</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> ./toolchain/gcc-arm-9.2-2019.12-x86_64-arm-none-linux-gnueabihf /bin/gcc-arm-toolchain<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># Get the header files and the compiled library too</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> ./toolchain/manufacturer_provided_files/lib /usr/lib/emod<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> ./toolchain/manufacturer_provided_files/include /usr/include/emod<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># Update the path so as to include Go</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;/usr/local/go/bin:</span><span class="si">${</span><span class="nv">PATH</span><span class="si">}</span><span class="s2">&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># Update compilation vars for GO:</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="c1"># Target architecture to compile against</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    ENV <span class="nv">GOARCH</span><span class="o">=</span><span class="s2">&#34;arm&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="c1"># Target OS to compile against</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    ENV <span class="nv">GOOS</span><span class="o">=</span><span class="s2">&#34;linux&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="c1"># Enable Go&#39;s interation with pure C code</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    ENV <span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="s2">&#34;1&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="c1"># Tell Go which compiler to use for C code (i.e. the gcc ARM cross-compiler we loaded before)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    ENV <span class="nv">CC</span><span class="o">=</span><span class="s2">&#34;/bin/gcc-arm-toolchain/bin/arm-none-linux-gnueabihf-gcc&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="c1"># Tell the C compiler where to look for headers (i.e. *.hpp and *.h files).</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    ENV <span class="nv">CGO_CFLAGS</span><span class="o">=</span><span class="s2">&#34;-I/usr/include/emod/&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="c1"># tell the C compiler where to look for libraries (i.e. *.a files)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    ENV <span class="nv">CGO_LDFLAGS</span><span class="o">=</span><span class="s2">&#34;-L/usr/lib/emod/&#34;</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>In order to leverage the above, we need to run the following command from a directory whose contents resemble:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">|
</span></span><span class="line"><span class="cl">+ ---   Dockerfile
</span></span><span class="line"><span class="cl">+ --- + toolchain/
</span></span><span class="line"><span class="cl">      |
</span></span><span class="line"><span class="cl">      + --- manufacturer_provided_files/
</span></span><span class="line"><span class="cl">      + --- gcc-arm-9.2-2019.12-x86_64-arm-none-linux-gnueabihf/
</span></span></code></pre></td></tr></table>
</div>
</div><p>The contents of the toolchain directory are:</p>
<ul>
<li>
<p><em>GNU Toolchain for the ARM Cortex-A Family</em>: This directory contains the <code>C++</code> compiler we point <code>go</code> to through the <code>CC</code> environment variable. It will be in charge of compiling the <code>C++</code> code the <code>go</code> bindings depend on. It can be downloaded <a href="https://developer.arm.com/-/media/Files/downloads/gnu-a/9.2-2019.12/binrel/gcc-arm-9.2-2019.12-x86_64-arm-none-linux-gnueabihf.tar.xz?revision=fed31ee5-2ed7-40c8-9e0e-474299a3c4ac&amp;hash=C54244E4E3875AACABA1DFB301ACA805">here</a>. You can also browse the different toolchains <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads/9-2-2019-12">here</a>. Once downloaded, you will have to decompress them with <code>tar -xzf gcc-arm-9.2-2019.12-x86_64-arm-none-linux-gnueabihf.tar.xz</code>. The resulting directory is what needs to be stored under the <code>toolchain/</code> directory.</p>
</li>
<li>
<p><em>Original Manufacturer Libs</em>: These are, as the name implies, provided by the manufacturer. You&rsquo;ll also need to decompress them (probably with <code>tar -xzf &lt;filename&gt;</code> too) and place them under the <code>toolchain/</code> directory as well.</p>
</li>
</ul>
<p>Finally, we can <code>cd</code> into the directory outlined above and run:</p>
<pre><code>docker build -t cc-embedded .
</code></pre>
<p>This will generate the <code>cc-embedded</code> <em>docker image</em> that can be run with:</p>
<pre><code>docker run --rm -it cc-embedded bash
</code></pre>
<p>Note the <code>--rm</code> flag will remove the container once we close the session (so as to keep our <em>docker</em> daemon tidy) and the <code>-it</code> flags will keep <code>STDIN</code> attached and allocate a pseudo-<code>TTY</code>, respectively. This prevent the container from staring and closing, which would be the case if we did not interact with the provided shell interactively. We also recommend mounting code we want to compile into the container with the help of <a href="https://docs.docker.com/storage/volumes/">volumes</a>.</p>
<p>For instance, if we pull the examples from <a href="https://bitbucket.org/pickdata-fw/emod_controller_binding_go/src/master/">bitbucket.org:pickdata-fw/emod_controller_binding_go</a>, we can mount the examples into the container (assuming the repository is <code>cloned</code> as <code>go_bindings_repo</code>) with:</p>
<pre><code>docker run --rm -it -v /path/to/go_bindings_repo:/repo cc-embedded bash
</code></pre>
<p>The above would expose the repository within the container on the <code>/repo</code> directory. Once within it, we can just <code>cd</code> into an example and run:</p>
<pre><code># Create a module for the example
go mod init example/foo

# Get the module's requirements
go mod tidy

# And build it!
go build
</code></pre>
<p>As all the environment variables have been specified at the time of the image&rsquo;s creation, we can really simplify the building process! What&rsquo;s more, as the repository is mounted as a volume, the build process will generate the executable within our host&rsquo;s directory, no need to run <code>docker cp</code> anymore :sunglasses:</p>
<p>All in all, given these general ideas we believe it is feasible to adapt this process to any project you might be working on!</p>
<hr>
<p>If you have any comments, questions or suggestions, feel free to drop me an email!</p>
<p>Thanks for your time! Hope you found this useful :smile_cat:</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Cross Compiling stuff with Docker on twitter"
        href="https://twitter.com/intent/tweet/?text=Cross%20Compiling%20stuff%20with%20Docker&amp;url=https%3a%2f%2fpcolladosoto.github.io%2fcross-cc%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Cross Compiling stuff with Docker on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpcolladosoto.github.io%2fcross-cc%2f&amp;title=Cross%20Compiling%20stuff%20with%20Docker&amp;summary=Cross%20Compiling%20stuff%20with%20Docker&amp;source=https%3a%2f%2fpcolladosoto.github.io%2fcross-cc%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Cross Compiling stuff with Docker on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fpcolladosoto.github.io%2fcross-cc%2f&title=Cross%20Compiling%20stuff%20with%20Docker">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Cross Compiling stuff with Docker on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpcolladosoto.github.io%2fcross-cc%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Cross Compiling stuff with Docker on whatsapp"
        href="https://api.whatsapp.com/send?text=Cross%20Compiling%20stuff%20with%20Docker%20-%20https%3a%2f%2fpcolladosoto.github.io%2fcross-cc%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Cross Compiling stuff with Docker on telegram"
        href="https://telegram.me/share/url?text=Cross%20Compiling%20stuff%20with%20Docker&amp;url=https%3a%2f%2fpcolladosoto.github.io%2fcross-cc%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://pcolladosoto.github.io/">Just another Jedi...</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
